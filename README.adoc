
* Estas instrucciones fueron validadas para los siguientes SO:

$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 14.04.4 LTS
Release:	14.04
Codename:	trusty

$ lsb_release -a
No LSB modules are available.
Distributor ID:    Kali
Description:    Kali GNU/Linux 2.0
Release:    2.0
Codename:    sana

* Instalar sistemas de tareas en python

$ sudo pip install invoke

* Instalar el entorno de virtual de python

$ sudo apt-get install python3.4-venv

* Descargar el codigo de la aplicacion de git

$ git clone https://(USERNAME)@bitbucket.org/fluidsignal/fluid-asserts.git

* Ingresar a la carpeta del codigo

$ cd fluid-asserts

* Las tareas de la herramienta de construcción son:

$ invoke --list

Para limpiar por completo el repositorio

$ invoke clean

* Para construir y ejecutar las pruebas se puede ejecutar directamente:

$ invoke test

* Para añadir nuevos modulos de soporte el formato es el siguiente:

   * fluidasserts/{formato}.py
   * fluidasserts/{protocolo}.py

Ejemplo:

   * touch fluidasserts/js.py
   * touch fluidasserts/html.py
   * touch fluidasserts/smtp.py
   * touch fluidasserts/ftp.py
   * touch fluidasserts/snmp.py

Dentro de cada modulo correspondiente se deben crear funciones tipo predicado,
es decir que hagan una pregunta que se responda verdadero o falso.  Ejemplos:

   * has_XXXX?
   * is_open?
   * is_close?
   * contains_XXX?

Los metodos al ser predicados siempre deben retornar True o False:

   * True si la vulnerabilidad esta abierta
   * False si la vulnerabilidad esta cerrada
   * True debe ser el valor por defecto de retorno ante cualquier duda

Siempre el nombre de las funciones debe ser en ingles y seguir la convencion
de nombres de python.  De esta forma desde un proyecto se podra usar asi:

from fluidasserts import js
js.is_obfuscated('Admin.js')

Notese que el metodo solo debe preocuparse por el formato del archivo, no
por su ubicación, pues de esto se encargaran los decoradores.  

Los decoradores son funciones que permiten separar la logica de la ubicación
de la logica de verificación de un formato.  La idea inicial es la siguiente:

@http_location('http://www.holacomoestas.com/ruta/')
js.is_obfuscated('Admin.js')

Esta estructura verificara si el archivo Admin.js esta ofuscado independiente
de donde este almacenado.  Asi por ejemplo si el archivo JS esta en un FTP,
solo debemos crear un decorador sin afectar la funcion js.is_obfuscated:

@ftp_location(10.1.1.1, '/hola/')
js.is_obfuscated('Admin.js')

Si por ejemplo el archivo esta en una carpeta compartida de Windows, solo
debemos crear el decorador:

@smb_location ....


* Adicionar nuevas caracteristicas:

El modelo de versionamiento que se utiliza el workflow GIT:

https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

tambien explicado en:

http://nvie.com/posts/a-successful-git-branching-model/
http://blog.javascripting.com/2014/12/05/continuous-deployment-with-github-circleci-heroku/

En este modelo basicamente tenemos las siguientes ramas:

   - master: codigo en producción y estable (en origin)
   - develop: codigo para integración de todo el desarrollo (en origin)
   - feature-XXXX: codigo del desarrollador 

Para comenzar a desarrollar una nueva caracteristica, se debe comenzar desde la rama
de develop

$ git checkout -b feature-XXX develop

Una vez finalizada la nueva caracteristica los cambios deben integrarse (merged) a develop:

$ git checkout develop            # Cambiar a la rama de desarrollo
$ git merge --no-ff feature-XXX   # Integrar la nueva caraceristica con la rama local de desarrollo
$ git branch -d feature-XXX       # Eliminar la rama local de la nueva caracteristica
$ git push origin develop         # Enviar a la rama central de desarrollo los cambios fusionados


Respecto a las reglas de estilo se debe usar las siguientes normas de estilo:

http://docs.openstack.org/developer/hacking/
https://www.python.org/dev/peps/pep-0008/
http://docs.python-guide.org/en/latest/writing/style/
http://blog.sideci.com/2015/12/14/style-guide-of-python-and-lint-tool/

Por este motivo durante la compilación se tienen previstas herramientas
de analisis de codigo sintactico que hacen que la sintaxis de nombres
se respete estrictamente. Esto es:

pylint
pep3
flake8
pyflakes
hacking

