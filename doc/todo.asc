= TODO
:lang:		es
:author:	Enginering Team
:email:		engineering@fluid.la
:revnumber:	v1.0
:revdate:	{date}

== Errores

. Solucionar los problemas de compilacion de YAML en CircleCI no ocurren, pero
  en los ambientes normales si

. Resolver los warnings de compilación de YAML (quitar YAML?)
  https://www.atlassian.com/git/tutorials/git-hooks/

. La generacion de txt sale con errores de visualicion en caracteres extraños
  al parecer son problemas de codificación.

== Dependencias

. El venv solo funciona bien en ubuntu, a andrew le toco hacer un hack para que
  funcione en version 3.5 y en sid, posiblemente sea mejor trabajar asi:
  instalar python en el sistema, el que sea, y luego desde pip instalar el venv
  para poder forzar el uso de una version particular con ==

. Las dependencias de desarrollo deberian ser otras a las dependencias de
  ejecucion, por tal motivo deben existir dos archivos de requirements, uno
  para desarrollo y otro para ejecucion: requirements-dev.txt?

. Ya esta la dependencia en ubuntu6 de libffi??

. requirements.txt a docker-py

. Separar la configuración que se encuentra en el codigo seleccionando una de
las siguientes bibliotecas:
https://bitbucket.org/ruamel/yaml
http://www.voidspace.org.uk/python/configobj.html
https://docs.python.org/3/library/configparser.html
https://pypi.python.org/pypi/python-decouple
https://github.com/osantana/prettyconf
https://github.com/ssato/python-anyconfig
https://bitbucket.org/dhagrow/profig/

== Versionamiento

. Adicionar tarea que permita hacer upload de la rama local de desarrollo y
  simplifique la tarea:
  $ inv upload
  $ git push origin ralvarez

. Eliminar los branch por caracteristicas y solo dejar el branch por persona.
.. Limpiar los branch de feature que estan en remote.

. Definir en la nueva documentación el nuevo workflow de trabajo simplificado
. Sera que toco hacer esto por la nueva forma de crear el branch:
  $ git branch --set-upstream-to=origin/master ralvarez

. Donde estoy en GIT
  $ git --no-pager log --graph --oneline --decorate --date=relative --all -10

. Crear las siguientes tareas de mantenimiento de los repositorios en el task:

. Contar algo antes de hacer el prune:
  $ git count-objects -v

. Mantenimiento al repositorio borrando ya los commits no asociados a un branch
  $ git gc --prune=now

. Si algunas ramas que estan remote y fueron sincronizadas localmente fueron
  eliminadas de remote, pueden purgarse localmente con:
  $ git remote prune origin

. Este comando parece que hace la limpieza local de ramas que ya no existen
  en remote???
  $ git fetch --all --prune

. Comandos a hacer localmente para eliminar la rama develop:
  $ git branch --set-upstream-to=origin/master ralvarez
  $ git branch -d develop
  $ git remote prune origin
  $ git gc --prune=now

. Utilizar stash para incluir soporte de descarga, stashing y merge de la 
  cabeza de master una vez ha ganado un proyecto adicional.
  $ git stash -u

== Estilo

. Reducir los errores de flake8

. Hay errores de flake8 que salen en el linting a traves de lint y esos mismos
  errores no salen en el linting que se dispara desde el pre-commit.

. Analizar la configuracion de pylint para ver si se puede personalizar en el
  Failed correspondiente, por determinado puntaje que logre el codigo

. Analizar cambio en la arquitectura de linters: frosted vs pyflakes
  https://github.com/klen/pylama

. Porque no pasa el flake8 de lint pero si el de pre_commit

== Documentación

. Clarificar que el requerimiento es que funcione pyinvoke y pyenv, punto,
  independiente del interprete de python. O clarificar en la documentacion el
  tema de los ambientes virtuales, las versiones, etc

. Sera mas facil clarificar que debe haber un commit por comentario y no muchos
  diff con muchos comentarios

. Añadir a la documentación la necesidad de tener instalado docker y de añadir
  el usuario local al grupo docker.

. Añadir a la documentación la necesidad de que en la maquina local la persona
  trabaje no como root, sino con un usuario no privilegiado y que ademas se
  llame como el usuario oficial de login de fluid.

. Revisar la documentación generada por Sphinx a Alabaster

. Guia sobre como debe documentarse un commit
  https://wiki.openstack.org/wiki/GitCommitMessages

. Adicionar guia de como hacer commits por cada caracteristica particular y
  por ende como fragmentar varios cambios en varios commit:
  http://nuclearsquid.com/writings/git-add/
  http://alblue.bandlem.com/2011/10/git-tip-of-week-interactive-adding.html

== Pruebas

. Incoportar en la suite de integracion las pruebas que hacen funcionar docker
  y ansible

. Pre.commit hooks in server side
  https://git-scm.com/book/en/v2/Customizing-Git-An-Example-Git-Enforced-Policy

. Volver a revisar tox o doit como herramientas de integracion
https://testrun.org/tox/latest/

. Tox testing para multiples versiones de python:
  https://discuss.circleci.com/t/testing-in-different-environments/450/2
  https://discuss.circleci.com/t/testing-with-multiple-python-versions/4420

. Pruebas unitarias de los mensajes de error en los logs?
  https://pypi.python.org/pypi/pytest-capturelog

. Hacer refactoring de las suites de pruebas para que sean menos
  repetitivas:
  http://doc.pytest.org/en/latest/parametrize.html

. Testing de multiples versiones de python en circleci
  https://ben.fogbutter.com/2016/02/20/testing-multiple-python-versions-on-circleci.html

. Crear archivo de configuracion de coverage que permita ademas de centralizar
  los parametros de configuracion de la aplicacion, establecer una meta
  de coverage antes de fallar:
  https://coverage.readthedocs.io/en/latest/config.html

== Construccion

. Tasks que manehen el deployment

. Adicionar cloc en el proceso de integracion continua y build

. Definir commandos para commit, pull request, etc en los archivos de
  construccion??

. https://hub.docker.com/r/generik/ansible/ Revisar la configuracion de las
  imagenes desde Ansible

. Utilizar el API de ansible para hacer test de asserts propios al sistema
  operativo???

. o en su efecto utilizar TestInfra http://testinfra.readthedocs.io/en/latest/

. Crear una imagen docker de FLUIDAsserts

. O con docker compose:
  http://www.heavybit.com/library/blog/opinionated-tour-of-testing-tools/

. Entre el import sorter de precommit y flake8 se contradicen.

== Empaquetamiento

. Añadir soporte de Wheel

. Paquete especificado con setup.py o setup.cfg

. Utilizar para el empaquetamiento distutils o distutils2 (packaging)

. Revisar la pertinencia del API de Mocks
  https://docs.python.org/dev/library/unittest.mock.html

. Revisar el mock de http con: https://github.com/gabrielfalcao/HTTPretty
  (problemas con python3)

. Revisar si el formato estandar sera ascii o utf-8
  https://docs.python.org/2.3/whatsnew/section-encodings.html
  https://docs.python.org/3/howto/unicode.html

. http://dl.acm.org/citation.cfm?id=2896929 Automatic web security unit
  testing: XSS vulnerability detection

== Productos

. Historico de cobertura con: https://coveralls.io/

. Historico de calidad de codigo: https://codeclimate.com/

. Integracion continua en Windows: https://www.appveyor.com/

. Deploy a heroku

== Virtualización

. El docker de la integración continua es 1.9 y el de ubuntu 14 y muy
  posiblemente las demas maquinas de desarrollao es 1.10 a 1.12.  Esto implica
  que algunos comandos de red no estan disponibles y por ende pueden fallar en
  la integración continua. Hay que analizar hacer downgrade en las maquinas
  locales, o puede ser que con docker compose el problema se abstraiga.
  https://github.com/weaveworks/weave/issues/2420
  http://stackoverflow.com/questions/34813343/what-method-docker-use-to-give-container-an-ip-address

. En vez de utilizar los scripts de inicio de docker, puede que docker compose
  facilite el inicio y fin de los diferentes servidores de docker asi como
  las especificación de las interfaces de red correspondientes.
http://stackoverflow.com/questions/31787426/can-circle-ci-use-docker-compose-to-build-the-environment
https://www.theodo.fr/blog/2016/05/straight-to-production-with-docker-ansible-and-circleci/

. Este wrapper permite manejar ambientes virtuales de python ya sea pyvenv o
  virtualenv, parece en inicio mas maduro que los otros
  http://pyvenvwrapper.readthedocs.io/en/latest/index.html tiene la ventaja de
  poder ser instalado via pip y por ende hacerlo mas independiente del
  empaquetamiento propio del sistema local

include::include/footer.adoc[]
