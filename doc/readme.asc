= README: FLUIDAsserts
:lang:                   es
:author:                 Enginering Team
:email:		         engineering@fluid.la
:revnumber:              v1.0
:revdate:                2016
:toc:                    macro
:toc-title:              Contenido
:icons:                  font
:source-highlighter:     pygments
:keywords:               fluidasserts, fluidsignal, fsg, unit testing

toc::[]

== Aplicación

Las instrucciones que se presentan a continuación han sido verificadas en los
siguientes sistemas operativos basados en Debian:

* Ubuntu 16.04.1 LTS aka LTS

[source, console]
----
$ lsb_release -a.
Distributor ID: Ubuntu
Description:    Ubuntu 16.04.1 LTS
Release:    16.04
Codename:   xenial
No LSB modules are available.
----

* Ubuntu 14.04.4 LTS aka trusty

[source,console]
----
$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 14.04.4 LTS
Release:	14.04
Codename:	trusty
----

* Kali GNU/Linux 2.0 aka sana

[source, console]
----
$ lsb_release -a
No LSB modules are available.
Distributor ID:    Kali
Description:    Kali GNU/Linux 2.0
Release:    2.0
Codename:    sana
----

* Debian GNU/Linux unstable (sid)

[source, console]
----
$ lsb_release -a.
Distributor ID: Debian
Description:    Debian GNU/Linux unstable (sid)
Release:        unstable
Codename:       sid
No LSB modules are available.
----

<<<
== Requerimientos

* Lo primero para comenzar a contribuir en el desarrollo es instalar el soporte
  en su sistema operativo para el sistema de tareas de Python llamado PyInvoke.
  Este sistema es el equivalente a Makefile y se instala utilizando el siguiente
  comando:

[source, console]
----
$ sudo pip install invoke
----

* Para no depender de las bibliotecas y versión de Python del sistema operativo
  particular de cada desarrollador y tener un ambiente independiente para el
  producto, se requiere instalar PyVenv:

[source, console]
----
$ sudo apt-get install python3.4-venv
----

* Para poder descargar e interactuar con el repositorio de código fuente en 
  donde se almancenan las diferentes versiones del producto debe instalarse
  GIT:

[source, console]
----
$ sudo apt-get install git
----

* Durante el proceso de construcción del producto se requieren algunas
  bibliotecas de desarrollo (cabeceras) asociadas a las dependencias. Para
  su instalación se procede asi:

[source, console]
----
$ sudo apt-get install libffi-dev
----

<<<
== Registro

* Si usted desea colaborar en el desarrollo del producto es necesario
  registrarse previamente en algunas plataformas que le serviran de ayuda
  a medida que añade o modifica código fuente.

* El código fuente se encuentra en un repositorio centralizado *GIT* 
  suministrado por el servicio *BitBucket*. El registro se realiza en 
  la siguiente dirección https://bitbucket.org/account/signup/, debe
  hacerse utilizando la dirección de correo electronico corporativo 
  (login@fluid.la) y el nombre de usuario debe seguir la siguiente 
  convención: *loginatfluid*.

* Si el registro fue satisfactorio usted deberia poder ingresar a esta
  dirección https://bitbucket.org/fluidsignal/fluid-asserts/ y visualizar
  desde ella el código fuente del producto.
  
* Posteriormente es necesario registrarse en el servicio de compilación e 
  integración continua *CircleCI*.  El registro en él se realiza en la 
  siguiente dirección https://circleci.com/integrations/bitbucket/ y debe 
  realizarse autorizando el acceso a la cuenta de *BitBucket* creada en los
  pasos anteriores.  

* Si el registro fue satisfactorio usted deberia poder ingresar a esta 
  dirección https://circleci.com/bb/fluidsignal/fluid-asserts y visualizar
  desde ella las mas recientes compilaciones del producto asi como sus 
  artefactos.

* Para poder realizar pruebas del producto contra diversidad de tecnologias,
  protocolos, productos y configuraciones vulnerables y no vulnerables de
  los mismos, se requiere utilizar la tecnología de contenedores, en particular
  la suministrada por *Docker*.  Para ello usted debe registrarse utilizando
  su dirección de correo corporativa (login@fluid.la) en la siguiente dirección
  https://cloud.docker.com/.  El *DockerID* asociado a este correo electronico
  debe ser *loginatfluid*.

* Una vez usted se ha registrado debe solicitar ser incluido en la organización
  *fluidsignal* que contiene las imagenes preconstruidas necesarias para 
  probar y desarrollar el software.  Esta solicitud la realiza por correo
  electronico a *engineering@fluid.la*.

<<<
== Descarga

* Finalizados las etapas anteriores puede procer a descargar el codigo del 
  repositorio central de FLUID:

[source, console]
----
$ git clone https://bitbucket.org/fluidsignal/fluid-asserts.git
Clonar en «fluid-asserts»...
Username for 'https://bitbucket.org': loginatfluid
Password for 'https://loginatfluid@bitbucket.org': 
remote: Counting objects: 565, done.
remote: Compressing objects: 100% (541/541), done.
remote: Total 565 (delta 267), reused 0 (delta 0)
Receiving objects: 100% (565/565), 142.79 MiB | 1.28 MiB/s, done.
Resolving deltas: 100% (267/267), done.
Comprobando la conectividad… hecho.
----

* El comando anterior descargará todo el repositorio de código completo del
  producto, permitiendo navegar por diferentes versiones y ramas.

* Una vez descargado podemos ingresar al repositorio y navegar en su contenido:

[source, console]
----
$ tree -a -L 1 fluid-asserts
.
├── circle.yml
├── conf
├── doc
├── fluidasserts
├── .git
├── .gitignore
├── .pre-commit-config.yaml
├── requirements.txt
├── setup.py
├── tasks.py
└── test
----

* Dentro de los archivos listados anteriorme se destacan los siguientes 
  directorios:

.Table Directorios
|===
|Nombre |Contenido

|conf
|Archivos de configuración requeridos.

|doc
|Archivos fuentes de la documentación del producto.

|test
|Código fuente de pruebas de unidad y mock.

|fluidasserts
|Código fuente del producto.

|build
|Directorio que se crea solamente en la construcción, no versionado y que
 contiene todos los artefactos generados.
|===

* Adicionalmente los siguientes archivos:

.Table Archivos
|===
|Nombre |Contenido

|circle.yml
|Configuración del sistema de integración continua Circle-CI

|.pre-commit-config.yml
|Configuración de pre-commit.  Se invoca antes de hacer commit (linting).

|setup.py
|Configuración de distutils que permite empaquetar el software automaticamente

|tasks.py
|Tareas automatizadas que permiten construir el software desde el fuente.

|MANIFEST.txt
|Lista de los archivos y directorios principales que hacen parte del producto.
|===

<<<
== Compilar

* Las diferentes acciones que pueden realizarse sobre el codigo se encuentran
  almacenadas en el archivo tasks.py y pueden conocerse ejecutando el siguiente
  comando:

[source, console]
----
$ inv --list
Available tasks:

  build          Costruye el software con sus dependencias.
  clean          Borra todos los archivos intermedios generados.
  deps           Instala dependencias requeridas en el ambiente virtual.
  dist           Genera los instaladores.
  doc            Genera la documentación de forma automatica.
  freeze         Envoltura de pip freeze para cuidar las dependencias.
  install        Instala el proyecto en el ambiente virtual local.
  lint           Realiza analisis de estilo sobre todo el software.
  not_staged     Cambios pendientes pasar al area de stage.
  not_commited   Cambios pendientes de pasar de stage a commit.
  pre_commit     Ejecuta hooks de pre-commit (linters).
  re_commit      Actualiza ultimo commit con otros cambios a incluir en el.
  self           Genera información de contexto para reporte de errores.
  setup_dev      Configura ambiente de desarrollo: pre-commit, commitmsg.
  shell          Ejecuta una shell nueva dentro del ambiente virtual.
  style          Realiza mejoras automaticas de estilo.
  sync           Descarga cambios ocurridos en repositorio remoto central.
  test           Ejecuta las pruebas de unidad que verifican el software.
  venv           Crea un ambiente virtual de Python independiente del SO.
----

[TIP]
Puede ejecutarse el comando "inv" o "invoke" indistintamente.

<<<
== Configurar

* Para comenzar a realizar cambios sobre el repositorio deben configurarse los
  usuarios con los cuales quedaran registrados sus cambios:

[source, console]
----
$ git config --global user.name "Faustino Asprilla"
$ git config --global user.email fasprilla@fluid.la
----

* Usted puede verificar si los cambios estan registrados mediante la orden:

[source, console]
----
$ git config --list
user.email=fasprilla@fluid.la
user.name=Faustino Asprilla
alias.ahead=log origin/master..HEAD --oneline
push.default=matching
----

* Luego de esto deben instalarse las configuraciones propias del ambiente de 
  desarrollo, entre ellas esta los hooks de precommit, el mensaje de commit
  y otras relacionadas con un ambiente de desarrollo homogeneo:

[source, console]
----
$ inv setup_dev
...
**** FLUIDAsserts: Running $ pre-commit install.
pre-commit installed at XXX/fluid-asserts/.git/hooks/pre-commit
**** FLUIDAsserts: Running $ git config --global commit-template ....
----

* Si los pre-commit quedaron correctamente instalados y el codigo descargado
  se encuentra en su versión estable se pueden invocar los hooks de pre-commit
  y ver la siguiente salida:

[source, console]
----
$ inv pre_commit
**** FLUIDAsserts: Running $ pre-commit run --all-files.
pylint..................................................................Passed
autopep8................................................................Passed
Sort python imports.....................................................Passed
Fix End of Files........................................................Passed
Fix python encoding pragma..............................................Passed
Fix double quoted strings...............................................Passed
Trim Trailing Whitespace................................................Passed
Check docstring is first................................................Passed
Check for added large files.............................................Passed
Check python ast........................................................Passed
Check for case conflicts................................................Passed
Check Yaml..............................................................Passed
Flake8..................................................................Passed
----

* Verificado que el software descargado cumple con las verificaciones estaticas
  podemos proceder a realizar el proceso de construcción y prueba para
  verificar que en la maquina local el software se ejecuta a la perfección:

[source, console]
----
$ inv test
**** FLUIDAsserts: Creating virtual environment.
**** FLUIDAsserts: Installing dependencies.
....
**** FLUIDAsserts: Building from source.
**** FLUIDAsserts: Installing FLUIDAsserts in BUILD_DIR by symlink.
**** FLUIDAsserts: Testing library.
========================== test session starts ================================
platform linux -- Python 3.4.3, pytest-2.9.2, py-1.4.31, pluggy-0.3.1 --
XXXXX/git/fluid-asserts/build/venv/bin/python3.4
cachedir: .cache
rootdir: XXXXX/git/fluid-asserts, inifile: 
plugins: cov-2.3.1
collected 10 items 

test/test_pdf.py::test_pdf_has_author_open PASSED
test/test_pdf.py::test_pdf_has_creator_open PASSED
test/test_pdf.py::test_pdf_has_producer_open PASSED
test/test_pdf.py::test_pdf_has_author_close PASSED
test/test_pdf.py::test_pdf_has_creator_close PASSED
test/test_pdf.py::test_pdf_has_producer_close PASSED
test/test_http.py::test_access_control_allow_origin_open PASSED
test/test_http.py::test_access_control_allow_origin_close PASSED
test/test_http.py::test_cache_control_open PASSED
test/test_http.py::test_cache_control_close PASSED
----

* La salida anterior muestra la ejecución satisfactoria de todo el conjunto de
  pruebas de la versión descargada.  Es decir, el software compila y se ejecuta
  sin inconvenientes.

* La invocación de las pruebas de unidad contiene un modulo de calculo de 
  cobertura.  Este modulo permite saber cuanto del codigo del producto ha sido 
  ejecutado por las pruebas, es decir, cuanto del codigo ha sido sometido a 
  prueba.  De esta forma podemos saber cual modulo requiere aun mas pruebas 
  automaticas:

[source, console]
----
----------- coverage: platform linux, python 3.4.3-final-0 -----------
Name                       Stmts   Miss  Cover
----------------------------------------------
fluidasserts/__init__.py       4      0   100%
fluidasserts/cookie.py        27     27     0%
fluidasserts/ftp.py           27     27     0%
fluidasserts/http.py         138     94    32%
fluidasserts/http_ssl.py      40     40     0%
fluidasserts/pdf.py           19      0   100%
fluidasserts/smtp.py          10     10     0%
fluidasserts/ssh.py            5      5     0%
fluidasserts/tcp.py           27     27     0%
----------------------------------------------
TOTAL                        297    230    23%
Coverage annotated source written to dir build/coverage/annotate
Coverage HTML written to dir build/coverage/html
Coverage XML written to file build/coverage/results.xml
----

* La salida anterior nos muestra que el modulo de PDF tiene pruebas al 100%, 
  que el modulo de HTTP es probado solo parcialmente (32%) y que otros 
  modulos no son probados y aun no disponen de pruebas de unidad.

* Una excelente forma de comenzar a aportar y a conocer el código fuente
  respectivo es comenzar a crear pruebas automatizadas para el código
  existente.

<<<
== Versionar

Una vez usted ha descargado el codigo mediante las instrucciones anteriores y 
ha verificado que este se ejecuta y compila en su ambiente local, es posible
comenzar a jugar con el y a generar nuevas caracteristicas en el mismo.

Para ello es importante conocer el flujo de trabajo mediante el cual se 
generan estas nuevas versiones locales y como se integran con las de otros 
desarrolladores del equipo.

El concepto que permite agrupar un conjunto de cambios sobre los archivos y 
diferenciarlos de otros cambios se conoce como *branch*, a lo largo de este
documento lo llamaremos *rama*.  Las ramas pueden ser locales, si solo estan
en su computador, o ramas remotas si estan en el servidor central *BitBucket*.

FLUID para cada producto ha determinado disponer de 2 ramas remotas:

master:: Es la rama que contiene la ultima versión estable del software,
develop:: Es la ramma que contiene la versión en la que todos los
          desarrolladores integran sus cambios.

Estas son las unicas ramas que se almacenaran de forma permanente en los 
servidores centrales.  Sin embargo usted puede tener tantas ramas locales 
quiera.

Para ver las ramas que fueron descargadas al realizar *clone* puede realizar
el siguiente comando:

[source, console]
----
$ git branch
  develop
* master
----

La salida anterior indica que tanto las ramas *develop* como *master* fueron
descargadas y que actualmente usted se encuentra en el directorio actual 
trabajando sobre la rama *master*.  Si quiere comenzar a hacer nuevas mejoras
deberia cambiarse a la rama de desarrollo:

[source, console]
----
$ git checkout develop
$ git branch
* develop
  master
----

Lo recomendable sin embargo es que usted cree una rama de desarrollo propia
llamada *login* sobre la cual todos los cambios realizados por usted quedan 
asociados en dicha rama, pueden ser enviados temporalmente a *BitBucket* y 
consecuentemente puden ser verificados por el integrador continuo *CircleCI*.

Para crear esta rama usted solo debe proceder asi:

[source, console]
----
$ git branch ralvarez
$ git checkout ralvarez
$ git branch
  develop
  master
* ralvarez
----

o una versión simplificada que obtiene el mismo resultado:

[source, console]
----
$ git checkout -b ralvarez develop
----

Desde este momento todos los cambios que usted realice pueden diferenciarse
de las ramas *develop* y *master*.  Es importante entender que una rama no 
es más que una etiqueta para los cambios que usted realice, si usted elimina
la etiqueta los cambios asociados no desaparecen, es decir, las ramas son 
una forma de agrupar cambios y luego integrarlos facilmente.

Desde este momento en adelante su objetivo es desarrollar nuevas
funcionalidades en su rama de desarrollo local, verificar las funcionalidades
usando pruebas de unidad, mejorar la sintaxis usando los linters, etc.

Cuando usted crea que la funcionalidad que ha desarrollado ya es de mostrar,
lo que debe realizar es pasarla del estado *no controlado* al segundo estado
*staged*:

[source, console]
----
$ git add ARCHIVO
----

Esto hace que el archivo quede marcado como preparado para ser registrado en 
un cambio.  Usted mientras desarrolla y se va dando cuenta que el archivo 
esta quedando mejor y debe ser preparado para el estado final *commit*, debe
primero hacer el comando anterior. Si usted se arrepiente de haberlo preparado
para commit puede hacer:

[source, console]
----
$ git reset ARCHIVO
----

Para saber si un archivo particular esta preparado preparado para commit
(*staged*) o no controlado puede utilizar el siguiente comando:

[source, console]
-----
$ git status
-----

Cuando usted ha finalizado una funcionalidad y por ende el codigo nuevo se
encuentra en el *stage*, usted puede proceder a hacer *commit* del codigo. 
Hacer *commit* no es más que darle un identificador de por vida a los 
cambios que usted ha creado, es asignarle un identificador eterno a ese
diferencial o nueva funcionalidad que usted ha creado.  El estado de *commit*
es por ende el estado final de un cambio.

Para hacer commit de un cambio se recomienda hacerlo usando la siguiente
sintaxis:

[source, console]
----
$ git commit --verbose
----

Esta sintaxis invocara un editor de texto, indicando los archivos que contienen
cambios en el *commit* y ademas la opción *-v* o *--verbose* hace que en el 
editor, en la parte final se vea el *diff* de los cambios realizados.  Asi
es mas facil dar una explicación de que fue cambiado y porque.

Dado que *git* es un sistema de control de versiones distribuido, el hacer
commit de un cambio no significa que todos los demas desarrolladores lo ven,
significa es que el cambio ha sido "bautizado" con un identificador y que 
puede ser enviado a otros repositorios centrales o de otros desarrolladores
compañeros.  Es decir, en este punto del desarrollo el codigo sigue solo
en su maquina local.

Esta es una situación peligrosa, sin embargo usted puede gracias a las rama
que creamos anteriormente enviar todo su repositorio al servidor central y
mantener su codigo de desarrollo respaldado en *BitBucket* sin afectar las
ramas *master* y *develop*.

Para ello el comando a realizar es el siguiente:

[source, console]
----
$ git push origin ralvarez
----

Con ello sus commits son respaldados en dicha rama en el servidor central y
adicionalmente el servidor de integración continua dispara una compilación
de forma automatica para ejecutar pruebas de sus cambios e indicarle si 
sus cambios no han hecho un daño en otras funcionalidades.  Para este 
punto es que se le pedia que creara credenciales en *CircleCI*.

Si la integración continua es satisfactoria, significa que usted añadio 
una nueva funcionalidad y no hiciste ningun daño en la base de codigo anterior.
Esto le permite ingresar a la interfaz web de *BitBucket* y hacer un 
*pull request* en adelante um *PR*.

Los *PR* son una solicitud de adición de los cambios de su rama a la rama de 
*develop*.  Por eso siempre un *PR* siempre tienen una rama origen (su login) y
una rama destino (*develop*).  Un *PR* puede ser tambien visto como una 
solicitud de revisión de pares por un  tercero que puede revisarla a mano para
encontrar algun error adicional o si no encuentra ningún problema *aprobar* el
*PR* y luego hacer *merge* de los cambios enviados a la rama oficial.

<<<
== Fusionar

El escenario anterior es el escenario más feliz de todos, en el que solo 
hay un desarrollador haciendo cambios sobre la ultima versión (*HEAD*) de la
rama *develop*.  Sin embargo es un escenario que nunca va a suceder, pues 
si de desarrollar software solo con una persona, no necesitamos *git*.

La vida real es que de forma simultanea Alex, Santi y Yerman descargan la
ultima versión de la rama *develop* y cada uno en sus ramas locales hacen
cambios.  En función de sus proyectos, dedicación y habilidad algunos
terminaran primero que otros, por ende los ultimos en hacer *PR* estarán
haciendo una solicitud de añadir código sobre una versión vieja de *develop*
pues ya ha sido integrado a la rama el *PR* del primero.

En este caso antes de hacer el *PR* cada desarrollador es responsable de
volver a sincronizarse con el estado actual de *develop*:

[source, console]
----
$ git fetch
----

Esta instrucción descarga todo el repositorio central, todas las ramas, todos
los commits, sin embargo simplemente estan disponibles para analisis, no 
significa que eso afecte sus archivos locales esten como *no controlados*, 
en *stage* o ya con *commit*.  Tampoco cambia su rama de trabajo actual, 
que si hemos seguido con este flujo sigue siendo *ralvarez*.

Una buena idea es verificar que tan lejos estamos de la rama *develop*
descargada.  Para realizar esto invocamos un analisis diferencial desde
nuestra rama a la rama *develop* descargada:

[source, console]
----
$ git diff --stat HEAD..develop
----

Si la salida al comando anterior es vacia, significa que no tenemos nada
que integrar y por ende nuestro código va a ser el primero en ser integrado.
Si por el contrario la salida del comando anterior genera algunas estadisticas
significa que debemos seguir con los siguientes pasos.

Dado que el trabajo de integración puede ser muy frecuente, se han creado
un *task* llamado *sync* que realiza estos comandos anteriores por nosotros:

[source, console]
----
$ inv sync
**** FLUIDAsserts: Running $ git remote -v.
origin             https://bitbucket.org/fluidsignal/fluid-asserts.git (fetch)
origin             https://bitbucket.org/fluidsignal/fluid-asserts.git (push)
**** FLUIDAsserts: Running $ git fetch -v origin.
De https://bitbucket.org/fluidsignal/fluid-asserts
 = [up to date]      develop    -> origin/develop
 = [up to date]      master     -> origin/master
**** FLUIDAsserts: Running $ git branch.
  develop
  master
* ralvarez
**** FLUIDAsserts: Running $ git diff --stat HEAD..develop.
----

Si la salida al comando anterior fuera asi:

[source, console]
----
**** FLUIDAsserts: Running $ git diff --stat HEAD..develop.
 doc/api.asc    |   3 -
 doc/design.asc |  20 -----
 doc/readme.asc | 564 ++++++++++++++++++----------------------
 doc/todo.asc   |  27 ------
 tasks.py       |  73 ++++++----------
 5 files changed, 115 insertions(+), 572 deletions(-)
----

Debemos proceder con el siguiente paso: hacer *merge*.  Esto es, fusionar
a la rama actual (login) las mejoras que otros lograron hacer llegar al
repositorio primero.

[source, console]
----
$ git merge develop
----

En el mejor de los escenarios este comando integrara de forma automatica
(*fast forward* en terminos de *git*) los cambios de otros a nuestra rama.
Si de forma automatica *git* no pudo integrarlo, el comando indicará como 
proceder para integrar los cambios.

En resumen, si usted espera mucho para integrar sus cambios, mas veces le 
va a tocar integrarse con los cambios de los demas, mas dificil sera la
integración.  Esto es un estimulo indirecto a hacer funcionalidades 
pequeñas y graduales y constantemente integrarlas.

Recuerde que una vez ha realizado el merge, su rama sigue necesitando 
ser enviada al repositorio central, por ende recuerde realizar los pasos
finales de la sección anterior.

Finalmente si usted ha hecho *fetch* y quiere ver que tan lejos esta su 
rama de la rama a la cual se va a integrar, o a cualquier otra rama, puede
utilizar el siguiente comando:

[source, console]
----
$ git log --oneline --decorate --graph --boundary --date-order develop..master
----

<<<
== Estilo

Respecto al contenido de los archivos que hacen parte del producto las reglas 
son las siguientes:

Código fuente:: *Python* (extensión *.py*) de ser posible, de requerirse 
scripts adicionales estos deben estar en *Bash* (extensión *.sh*).  El idioma 
del código fuente debe ser en *ingles* y los comentarios en *español*.
Documentación:: La documentación separada del código fuente (como este
documento) debe estar construida en el lenguaje *AsciiDoc* (extensión *.asc*)
y en idioma *español*.

Asi como en un idioma existe una forma de hablar elegantemente y tambien se
puede hablar como *nea*, programar tambien se puede hacer con elegancia o 
programar como *nea*.  La programación y la automatización son un cambio
disruptivo que *FLUID* esta realizando a futuro, por tal motivo todo el
código fuente debe seguir un *Python* excelentemente escrito.

Para ello y no reinventar la rueda FLUID se acoge estrictamente a los
estandares de lo que es un *buen Python* desarrollados po la comunidad:

PEP0008:: https://www.python.org/dev/peps/pep-0008/[Código fuente]
PEP0257:: https://www.python.org/dev/peps/pep-0257/[Documentación]

Algunos enlaces adicionales de ayuda del buen Python son:

* http://docs.openstack.org/developer/hacking/
* http://docs.python-guide.org/en/latest/writing/style/
* http://dolphm.com/pep257-good-python-docstrings-by-example/
* http://blog.sideci.com/2015/12/14/style-guide-of-python-and-lint-tool/
* http://google.github.io/styleguide/pyguide.html

Como nada que realice un humano es consistente, nada mejor que la
automatización para garantizar la adherencia a los estandares de nombramiento
y codificación.  El concepto de *linting* o verificación de estilo
esta embebido desde el inicio en el repositorio del producto y por ende
puede invocarse diferentes utilidades que le ayudan a verificar en cada
momento si el código cumple con los estandares definidos:

[source, console]
----
$ inv lint
**** FLUIDAsserts: Linting with pydocstyle.

**** FLUIDAsserts: Linting with flake8.

**** FLUIDAsserts: Linting with pylint.

----

Los linters que se invocan permiten verificar todas las reglas propias
de los estandares.  Es decir, un *linter* es un programa que verifica
y rechaza el código escrito en *nea Python*.

Para ayudar con la tarea de hablar un *buen Python* se ha incluido un 
arreglador automatico llamada *autopep8*.  Este puede ser invocado asi:

[source, console]
----
$ inv style
**** FLUIDAsserts: Correcting style with autopep8.
[file:tasks.py]
--->  Applying global fix for E265
--->  Applying global fix for W602
--->  0 issue(s) to fix {}
[file:setup.py]
--->  Applying global fix for E265
--->  Applying global fix for W602
--->  0 issue(s) to fix {}
----

Es importante corregir todo este tipo de errores antes de hacer commit,
pues el repositorio tiene una configuración que antes de hacer *commit*
verifica el cumplimiento estricto de todos estos estandares.  Para 
verificar si el codigo pasara las verificaciones podemos ejecutar:

[source, console]
----
$ inv pre_commit
----

Como regla general todos los archivos de texto plano deben tener como
máximo 80 columnas incluido el fin de linea, es decir a 79 caracteres
esta el ultimo caracter visible.  Las lineas no deben tener espacios en
blanco antes del fin de linea (*trailing whitespace*) y de igual forma
no deben existir lineas en blanco al final del archivo.

Para los que ven la programación como un medio para aprender a usar un
editor para hombres (*emacs*), adjunto el archivo de configuración que
con unas pequeñas lineas de *LISP* pone el editor a funcionar para 
estas reglas:

.$ tail -7 ~/.emacs.d/init.el
[source, cl, linenums]
----
;; permite visualizar las columnas en la barra de estado
(setq column-number-mode t)

;; estable el limite en 79 columnas y lo habilita para AsciiDoc y codigo
(setq column-enforce-column 79)
(add-hook 'prog-mode-hook 'column-enforce-mode)
(add-hook 'adoc-mode-hook 'column-enforce-mode)
----

Evite a toda costa los nombres de archivo en mayuscula y con caracteres
especiales de forma que se maximice la compatibilidad con multiples
sistemas operativos.

include::include/footer.asc[]

////

Una vez finalizada la nueva caracteristica los cambios deben integrarse (merged)
 a develop:

$ git checkout develop            # Cambiar a la rama de desarrollo
$ git merge --no-ff feature-XXX   # Integrar la nueva caraceristica con la rama local de desarrollo
$ git branch -d feature-XXX       # Eliminar la rama local de la nueva caracteristica
$ git push origin develop         # Enviar a la rama central de desarrollo los cambios fusionados

ParaQue tan lejos se encuentra la rama actual de desarrollo de la de master:


seccion de creacion de pruebas de unidad, fixtures y creacion de codigo
pendiente.

Revertir commits:

A -> B -> C -> D -> HEAD

para volver a quedar en A:

en otra carpeta:

$ git clone ...
$ git checkout develop
$ git revert --no-commit D
$ git revert --no-commit C
$ git revert --no-commit B
$ git commit -m'the commit message'
$ git push

En la carpeta original

$ git pull?? o git fetch??

http://stackoverflow.com/questions/1463340/revert-multiple-git-commits


////
