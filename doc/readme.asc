= README: FLUIDAsserts
:lang:		es
:author:	Enginering Team
:email:		engineering@fluid.la
:revnumber:	v1.0
:revdate:	2016

== Aplicación

Las instrucciones que se presentan a continuación han sido verificadas en los
siguientes sistemas operativos basados en Debian:

* Ubuntu 16.04.1 LTS aka LTS
[source,bash]
----
$ lsb_release -a.
Distributor ID: Ubuntu
Description:    Ubuntu 16.04.1 LTS
Release:    16.04
Codename:   xenial
No LSB modules are available.
----

* Ubuntu 14.04.4 LTS aka trusty
[source,bash]
----
$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 14.04.4 LTS
Release:	14.04
Codename:	trusty
----

* Kali GNU/Linux 2.0 aka sana
[source, bash]
----
$ lsb_release -a
No LSB modules are available.
Distributor ID:    Kali
Description:    Kali GNU/Linux 2.0
Release:    2.0
Codename:    sana
----

== Requerimientos

* Lo primero para comenzar a contribuir en el desarrollo es instalar el soporte
  en su sistema operativo para el sistema de tareas de Python llamado PyInvoke.
  Este sistema es el equivalente a Makefile y se instala utilizando el siguiente
  comando:
[source,bash]
----
$ sudo pip install invoke
----

* Para no depender de las bibliotecas y versión de Python del sistema operativo
  particular de cada desarrollador y tener un ambiente independiente para el
  producto, se requiere instalar PyVenv:
[source,bash]
----
$ sudo apt-get install python3.4-venv
----

* Para poder descargar e interactuar con el repositorio de código fuente en 
  donde se almancenan las diferentes versiones del producto debe instalarse
  GIT:
[source,bash]
----
$ sudo apt-get install git
----

* Durante el proceso de construcción del producto se requieren algunas
  bibliotecas de desarrollo (cabeceras) asociadas a las dependencias. Para
  su instalación se procede asi:
[source, bash]
----
$ sudo apt-get install libffi-dev
----

== Registro

* Si usted desea colaborar en el desarrollo del producto es necesario
  registrarse previamente en algunas plataformas que le serviran de ayuda
  a medida que añade o modifica código fuente.

* El código fuente se encuentra en un repositorio centralizado *GIT* 
  suministrado por el servicio *BitBucket*. El registro se realiza en 
  la siguiente dirección https://bitbucket.org/account/signup/, debe
  hacerse utilizando la dirección de correo electronico corporativo 
  (login@fluid.la) y el nombre de usuario debe seguir la siguiente 
  convención: *loginatfluid*.

* Si el registro fue satisfactorio usted deberia poder ingresar a esta
  dirección https://bitbucket.org/fluidsignal/fluid-asserts/ y visualizar
  desde ella el código fuente del producto.
  
* Posteriormente es necesario registrarse en el servicio de compilación e 
  integración continua *CircleCI*.  El registro en él se realiza en la 
  siguiente dirección https://circleci.com/integrations/bitbucket/ y debe 
  realizarse autorizando el acceso a la cuenta de *BitBucket* creada en los
  pasos anteriores.  

* Si el registro fue satisfactorio usted deberia poder ingresar a esta 
  dirección https://circleci.com/bb/fluidsignal/fluid-asserts y visualizar
  desde ella las mas recientes compilaciones del producto asi como sus 
  artefactos.

* Para poder realizar pruebas del producto contra diversidad de tecnologias,
  protocolos, productos y configuraciones vulnerables y no vulnerables de
  los mismos, se requiere utilizar la tecnología de contenedores, en particular
  la suministrada por *Docker*.  Para ello usted debe registrarse utilizando
  su dirección de correo corporativa (login@fluid.la) en la siguiente dirección
  https://cloud.docker.com/.  El *DockerID* asociado a este correo electronico
  debe ser *loginatfluid*.

* Una vez usted se ha registrado debe solicitar ser incluido en la organización
  *fluidsignal* que contiene las imagenes preconstruidas necesarias para 
  probar y desarrollar el software.  Esta solicitud la realiza por correo
  electronico a *engineering@fluid.la*.

== Descarga

* Finalizados las etapas anteriores puede procer a descargar el codigo del 
  repositorio central de FLUID:
[source,bash]
----
$ git clone https://bitbucket.org/fluidsignal/fluid-asserts.git
Clonar en «fluid-asserts»...
Username for 'https://bitbucket.org': ralvarezatfluid
Password for 'https://ralvarezatfluid@bitbucket.org': 
remote: Counting objects: 565, done.
remote: Compressing objects: 100% (541/541), done.
remote: Total 565 (delta 267), reused 0 (delta 0)
Receiving objects: 100% (565/565), 142.79 MiB | 1.28 MiB/s, done.
Resolving deltas: 100% (267/267), done.
Comprobando la conectividad… hecho.
----

* El comando anterior descargará todo el repositorio de código completo del
  producto, permitiendo navegar por diferentes versiones y ramas.

* Una vez descargado podemos ingresar al repositorio y navegar en su contenido:
[source,bash]
----
$ tree -a -L 1 fluid-asserts
.
├── circle.yml
├── conf
├── doc
├── fluidasserts
├── .git
├── .gitignore
├── .pre-commit-config.yaml
├── requirements.txt
├── setup.py
├── tasks.py
└── test
----

* Dentro de los archivos listados anteriorme se destacan los siguientes 
  directorios:

.Table Directorios
|===
|Nombre |Contenido

|conf
|Archivos de configuración requeridos.

|doc
|Archivos fuentes de la documentación del producto.

|test
|Código fuente de pruebas de unidad y mock.

|fluidasserts
|Código fuente del producto.

|build
|Directorio que se crea solamente en la construcción, no versionado y que
 contiene todos los artefactos generados.
|===

* Adicionalmente los siguientes archivos:

////
circle.yml
.pre-commit-config.yaml
setup.py
tasks.py
////

== Compilar

* Las diferentes acciones que pueden realizarse sobre el codigo se encuentran
  almacenadas en el archivo tasks.py y pueden conocerse ejecutando el siguiente
  comando:
[source,bash]
----
$ inv --list
Available tasks:

  build          Costruye el software con sus dependencias.
  clean          Borra todos los archivos intermedios generados.
  deps           Instala dependencias requeridas en el ambiente virtual.
  dist           Genera los instaladores.
  doc            Genera la documentación de forma automatica.
  freeze         Envoltura de pip freeze para cuidar las dependencias.
  install        Instala el proyecto en el ambiente virtual local.
  lint           Realiza analisis de estilo sobre todo el software.
  not_cached     Cambios pendientes pasar al area de cache (stage).
  not_commited   Cambios pendientes de pasar de cache (stage) a commited.
  pre_commit     Ejecuta hooks de pre-commit (linters).
  re_commit      Actualiza ultimo commit con otros cambios a incluir en el.
  self           Genera información de contexto para reporte de errores.
  setup_dev      Configura ambiente de desarrollo: pre-commit, commitmsg.
  shell          Ejecuta una shell nueva dentro del ambiente virtual.
  style          Realiza mejoras automaticas de estilo.
  sync           Descarga cambios ocurridos en repositorio remoto central.
  test           Ejecuta las pruebas de unidad que verifican el software.
  venv           Crea un ambiente virtual de Python independiente del SO.
----

[TIP]
Puede ejecutarse el comando "inv" o "invoke" indistintamente.

== Configurar

* Para comenzar a realizar cambios sobre el repositorio deben configurarse los
  usuarios con los cuales quedaran registrados sus cambios:
[source,bash]
----
$ git config --global user.name "Faustino Asprilla"
$ git config --global user.email fasprilla@fluid.la
----

* Usted puede verificar si los cambios estan registrados mediante la orden:
[source,bash]
----
$ git config --list
user.email=fasprilla@fluid.la
user.name=Faustino Asprilla
alias.ahead=log origin/master..HEAD --oneline
push.default=matching
----

* Luego de esto deben instalarse las configuraciones propias del ambiente de 
  desarrollo, entre ellas esta los hooks de precommit, el mensaje de commit
  y otras relacionadas con un ambiente de desarrollo homogeneo:
[source,bash]
----
$ inv setup_dev
...
**** FLUIDAsserts: Running $ pre-commit install.
pre-commit installed at XXX/fluid-asserts/.git/hooks/pre-commit
**** FLUIDAsserts: Running $ git config --global commit-template ....
----

* Si los pre-commit quedaron correctamente instalados y el codigo descargado
  se encuentra en su versión estable se pueden invocar los hooks de pre-commit
  y ver la siguiente salida:
[source,bash]
----
$ inv pre_commit
**** FLUIDAsserts: Running $ pre-commit run --all-files.
pylint..................................................................Passed
autopep8................................................................Passed
Sort python imports.....................................................Passed
Fix End of Files........................................................Passed
Fix python encoding pragma..............................................Passed
Fix double quoted strings...............................................Passed
Trim Trailing Whitespace................................................Passed
Check docstring is first................................................Passed
Check for added large files.............................................Passed
Check python ast........................................................Passed
Check for case conflicts................................................Passed
Check Yaml..............................................................Passed
Flake8..................................................................Passed
----

== Versionar

* Para adicionar nuevas caracteristicas se ha elegido el flujo de trabajo
  gitflow.

https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

tambien explicado en:

http://nvie.com/posts/a-successful-git-branching-model/
http://blog.javascripting.com/2014/12/05/continuous-deployment-with-github-circleci-heroku/

En este modelo basicamente tenemos las siguientes ramas:

   - master: codigo en producción y estable (en origin)
   - develop: codigo para integración de todo el desarrollo (en origin)
   - feature-XXXX: codigo del desarrollador

Para comenzar a desarrollar una nueva caracteristica, se debe comenzar desde la
rama de develop

$ git checkout -b feature-XXX develop

Una vez finalizada la nueva caracteristica los cambios deben integrarse (merged)
 a develop:

$ git checkout develop            # Cambiar a la rama de desarrollo
$ git merge --no-ff feature-XXX   # Integrar la nueva caraceristica con la rama local de desarrollo
$ git branch -d feature-XXX       # Eliminar la rama local de la nueva caracteristica
$ git push origin develop         # Enviar a la rama central de desarrollo los cambios fusionados


Para hacer commit se recomienda utilizar commit asi:

git commit --verbose

de esta forma el mensaje de commit siempre tendre abajo el diff para poder
añadir mejores comentarios al mismo

Que tan lejos se encuentra la rama actual de desarrollo de la de master:

git log --oneline --decorate --graph --boundary --date-order  develop...master

Que hacer cuando un commit daña el build de integracion:

////

para la seccion de contribución al software crear una seccion que hable sobre
adicionar al archivo autores la informacion correspondientes

doc/authors.asc



Revertir commits:

A -> B -> C -> D -> HEAD

para volver a quedar en A:

en otra carpeta:

$ git clone ...
$ git checkout develop
$ git revert --no-commit D
$ git revert --no-commit C
$ git revert --no-commit B
$ git commit -m'the commit message'
$ git push

En la carpeta original

$ git pull?? o git fetch??

http://stackoverflow.com/questions/1463340/revert-multiple-git-commits


sacar del stage

git reset HEAD doc/ejemplo.asc

////

== Estilo

Respecto a las reglas de estilo se debe usar las siguientes normas de estilo:

http://docs.openstack.org/developer/hacking/
https://www.python.org/dev/peps/pep-0008/
http://docs.python-guide.org/en/latest/writing/style/
http://dolphm.com/pep257-good-python-docstrings-by-example/
http://blog.sideci.com/2015/12/14/style-guide-of-python-and-lint-tool/
http://google.github.io/styleguide/pyguide.html
https://www.python.org/dev/peps/pep-0257/

Por este motivo durante la compilación se tienen previstas herramientas
de analisis de codigo sintactico que hacen que la sintaxis de nombres
se respete estrictamente. Esto es:

pylint
pep3
flake8
pyflakes
hacking

Idioma de documentacion

Idioma de programacion

LICENCIAMIENTO

Respecto a la implementación del esquema de licenciamiento existen multiples
alternativas de diseño.  Algunas de estas son:

   * Comunicacion constante con un servicio HTTP,
   * Certificados digitales de cliente con vencimiento,
   * CRL
   * OCSP
   * OCSP Stampling
   * TPM

https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol
https://en.wikipedia.org/wiki/OCSP_stapling
http://trousers.sourceforge.net/

include::include/footer.asc[]
